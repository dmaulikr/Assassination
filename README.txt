Assassination Documentation

The app worked in this way: When a user first opens the app, they have the option to either register or login in. After they register or log in, they are brought to the main page that has the facebook photo of their target along with their targets name, and an "assassinate" button that doesnt get activated unless the target is close in range. If the target is in range, and if user decides to click on the "assassinate" button, a push notification is sent to the target informing them that they have been killed.The user is then assassigned the target of the user they had just "assassinate".

The Core Bluetooth Framework works thus. The Peripheral device is constantly emitting low energy bluetooth signals. These signals contain an array of Service ids, and each of these Services contain an array of Characteristic ids. The Central device is constantly searching for Bluetooth signals that have a Service id that is contained in the array of Service ids that the Central is looking for. When the Central finds a matching signal, the Central device has the ability to connect to that device.

For this game, I had each phone run as a peripheral in the background, constantly emitting their unique identifier within the range of the phone's bluetooth device. When the app is opened, I fired up the Central device to search for the bluetooth signals of its target. If the Central discovers a matching peripheral, and if the signal strength is strong enough, I allowed the user the option to assassinate their target.

For my backend I used Parse to store my data tables. I had a table that kept track of each installation of the application, so I could send push notifications. I had a table for users with their accompanying facebook id, facbook photo, facebook name, email and password. I decided to integrate facebook so user's could no lie about their identity in order to confuse their assassin. I also had a table with two columns, one column which stored the email of the assassins, and the other column which stored the email of the targets. Additionally I will soon have a table for currently running games, which would have an entry for the game name, an entry for the game leader, and an array that would contain the participants of the game.

I will soon have a website running in order for people to register their own games. The website will simply prompt the user to give it a game name, a game leader, and a list of emails of the people in the game. The website would then invite the players to download the app if they haven't already, and if/once they have, give them the option to accept the game invitation. The game would then generate assassin - target pairs of the people who have accepted the invite. The app will be on the app store in the next couple of weeks after I have implemented more safe guards against cheating.

The distributed system aspect of this is the problem related to dealing with failure/cheating. I have set up a "heartbeat" so the phone would send a message to the server every minute along with the current state of the bluetooth. If the server stops receiving these messages, the user would get an email to either turn on the app if it is off, or to charge their phone if their phone is simply out of battery. An idea would also be to have the server constantly send silent push notifications to all the phones in order to wake up the phone in the background if it was killed - though it probably is unlikely that such an implementation would be approved by the iTunes Store. 

Other ideas to create a cheat resistant application includes having the target app also be searching for the uuid of its target, so if an assassin notifies the server that it killed its target, the server would then check with the target phone to see if it also had detected the assassin phone. Additionally, if a user clicks the assassinate button after gettting close to the target, the phone can check if it is connected to wifi, and if it is not, wait until it has connected to update the database. 

Other safeguards against cheating include having the user take a photo of the target instead of pressing the kill button - this would be an additional form of authentication and could result in an interesing array of "kill shots." Another idea is to have each assassination have a witness who is also participating in the game. This witness would confirm whether the assassination was successful by checking if both the assassin and target were within bluetooth range of the witness at the time of the kill. The witness, the assassin and the target would all vote whether the assassination was successful and the majority would have to vote that the assassination was successful in order for the kill to register

I look forward to working on this project further and similar projects in the future. Lately I have become increasingly interested in programming Bluetooth Arduino devices.

Hikari